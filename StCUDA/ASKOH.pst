<?xml version="1.0"?><st-source><!-- Name: ASKOHComment: <?xml version="1.0"?><st-source><time-stamp>From VisualWorks®, 7.8 of March 30, 2011 on January 30, 2012 at 9:36:51 am</time-stamp><do-it>	"	self new loadASKOH.	"	| access recentProfile connection cASKOH |	access := Store.DbRegistry.	recentProfile := access instVarAt: (access class instVarIndexFor: 'recentProfile').	connection := access instVarAt: (access class instVarIndexFor: 'connection').	access isConnected		ifFalse: 			[access connectionOrNil.			connection isNil ifTrue: [access connectTo: recentProfile]].	cASKOH := Store.Package allVersionsWithName: 'ASKOH'.	cASKOH notEmpty ifTrue: [cASKOH first loadSrc].	access closeConnection.	access connectionOrNil.	Refactory.Browser.RefactoringBrowser newOnClass: ASKOH.</do-it></st-source>DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'BOSS' '') #(#any 'Browser-BrowserUI' '') #(#any 'Browser-Namespace' '') #(#any 'Searchlight-Tools' '') #(#any 'StoreBase' '') #(#any 'Tools-Changes' ''))PackageName: ASKOHParcel: #('ASKOH')ParcelDirectory: parcels20180518\ASKOHParcelName: ASKOHPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'BOSS' #componentType #package) #(#name 'Browser-BrowserUI' #componentType #package) #(#name 'Browser-Namespace' #componentType #package) #(#name 'Searchlight-Tools' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'Tools-Changes' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('BOSS' '') #('Browser-BrowserUI' '') #('Browser-Namespace' '') #('Searchlight-Tools' '') #('StoreBase' '') #('Tools-Changes' ''))Version: 8.3.1.2Date: 9:17:41 AM May 18, 2018 --><time-stamp>From VisualWorks®, 8.3.1 of March 23, 2018 on May 18, 2018 at 9:17:41 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SearchItem2</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><class><name>SearchMethod2</name><environment>Smalltalk</environment><super>SearchItem2</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classname selector cToken_cHit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><class><name>BrowserPrintHierarchyTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>ASKOH</package></attributes></class><comment><class-id>Refactory.Browser.BrowserPrintHierarchyTool</class-id><body>BrowserPrintHierarchyTool puts the #printHierarchy results into a tab of the browser, if a class or namespace is selectedInstance Variables	text	&lt;ValueModel | String&gt;	The printed tree</body></comment><class><name>MessageForwarder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>ASKOH</package></attributes></class><comment><class-id>MessageForwarder</class-id><body>This class is a generic message forwarder. It's protocol is absolutely minimal, only #doesNotUnderstand: and couple of supporting methods prefixed with $_ to minimize the chance of clashes.Instance Variables:	object	&lt;Object&gt; undocumented</body></comment><class><name>SearchSmalltalk2</name><environment>Smalltalk</environment><super>SearchItem2</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cMethodToBeIndexed cClassToBeIndexed cToken_cMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><comment><class-id>SearchSmalltalk2</class-id><body>SearchSmalltalk2 indexAllMethodsSearchSmalltalk2 readTopIndexSearchSmalltalk2 saveTopIndexSearchSmalltalk2 commands</body></comment><class><name>Search</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><class><name>ASKOH</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><class><name>SearchToken2</name><environment>Smalltalk</environment><super>SearchItem2</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token cSearchMethod nOccurrence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ASKOH</package></attributes></class><shared-variable><name>TwoRaisedTo12</name><environment>SearchMethod2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer></initializer><attributes><package>ASKOH</package></attributes></shared-variable><shared-variable><name>Singleton</name><environment>SearchItem2</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>ASKOH</package></attributes></shared-variable><methods><class-id>Refactory.Browser.BrowserPrintHierarchyTool class</class-id> <category>interface specs</category><body package="ASKOH">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 199 130 999 638 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="ASKOH">recoverLastChangesCommand	&lt;command: #recoverLastChanges&gt;	^Command		label: (#_RecoverLastChanges &lt;&lt; #menus &gt;&gt; 'Recover Last Changes')		group: #launcher		bindings: #()</body></methods><methods><class-id>Tools.ModuleHolderDialog class</class-id> <category>interface specs</category><body package="ASKOH">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Select 				#defaultString: 'Select' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 480 320 1080 720 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #labels ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -180 1 -35 1 -100 1 -10 1 ) 					#name: #okButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #labels ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -40 1 ) 					#name: #module 					#flags: 0 					#clientKey: #module ) ) ) )</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="ASKOH">fileInChgSets	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	DeploymentOptionsSystem isDevelopment ifTrue: [Object fileInChgSets]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="ASKOH">menuItemRecoverLastChanges	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #recoverLastChanges	icon: nil	nameKey: nil	menu: #(#menuBar #tools)	position: 10.7&gt;	| aChangeList |	aChangeList := ChangeList new.	ChangeList openOn: aChangeList.	aChangeList recoverLast</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>tool registration</category><body package="ASKOH">browserPrintHierarchyToolClass	&lt;tool&gt;	^BrowserPrintHierarchyTool</body></methods><methods><class-id>SearchItem2</class-id> <category>accessing</category><body package="ASKOH">singleton	^self class singleton.</body><body package="ASKOH">singleton: aObject	^self class singleton: aObject.</body></methods><methods><class-id>SearchItem2 class</class-id> <category>accessing</category><body package="ASKOH">singleton	^Singleton.</body><body package="ASKOH">singleton: aObject	^Singleton := aObject.</body></methods><methods><class-id>SearchItem2 class</class-id> <category>instance creation</category><body package="ASKOH">new	"Answer a newly created and initialized instance."	^super new initialize.</body></methods><methods><class-id>SearchItem2 class</class-id> <category>utilities</category><body package="ASKOH">commands	"SearchItem2 singleton.SystemAnalyzer new byteSizeOfObject: SearchToken allInstances firstSystemAnalyzer new byteSizeOfObject: '123456'SystemAnalyzer new byteSizeOfObject: #symbolsSystemAnalyzer new byteSizeOfObject: #(1 2 3 4 5)SearchToken allInstancesSearchClass allInstancesSearchMethod allInstancesSearchSmalltalk indexAllMethods1SearchSmalltalk index_nMethod: 2000iMax = 1000nToken = 463166nClass = 998nMethod = 57626iMax = 2000nToken = 998376nClass = 1998nMethod = 120542"</body></methods><methods><class-id>SearchMethod2</class-id> <category>accessing</category><body package="ASKOH">aByteArrayFrom: cHit	| nPos aByteArray pos |	nPos := cHit size.	aByteArray := ByteArray new: nPos.	1 to: nPos		do: 			[:i |			pos := cHit at: i.			aByteArray at: i put: (pos &lt; 256 ifTrue: [pos] ifFalse: [0])].	^aByteArray.</body><body package="ASKOH">aClass	^('* class' match: classname)		ifTrue: [(classname copyUpTo: Character space) asQualifiedReference ifDefinedDo: [:aaClass | aaClass class]]		ifFalse: [classname asQualifiedReference value].</body><body package="ASKOH">aMethod	^self aClass compiledMethodAt: selector.</body><body package="ASKOH">aMethodDefinition	^MethodDefinition class: self aClass selector: selector.</body><body package="ASKOH">aWordArrayFrom: cHit	| nPos aWordArray pos |	nPos := cHit size.	aWordArray := WordArray new: nPos.	1 to: nPos		do: 			[:i |			pos := cHit at: i.			aWordArray at: i put: (pos &lt; 65536 ifTrue: [pos] ifFalse: [0])].	^aWordArray.</body><body package="ASKOH">addSource: aText	| aReadStream char subStream continue cHit token isNumber position |	cToken_cHit := IdentityDictionary new.	cHit := cToken_cHit at: aText asSymbol ifAbsentPut: [OrderedCollection new].	cHit add: 1.	aReadStream := aText asString readStream.	[aReadStream atEnd] whileFalse: 			[position := aReadStream position.			char := aReadStream next.			(self isAccepted: char)				ifTrue: 					[subStream := WriteStream on: String new.					subStream nextPut: char.					isNumber := char isDigit.					continue := true.					[continue] whileTrue: 							[char := aReadStream atEnd										ifTrue: [Character space]										ifFalse: [aReadStream next].							(self isAccepted: char)								ifTrue: 									[subStream nextPut: char.									isNumber ifTrue: [isNumber := char isDigit]]								ifFalse: 									[isNumber										ifFalse: 											[token := subStream contents asSymbol.											cHit := cToken_cHit at: token ifAbsentPut: [OrderedCollection new].											cHit add: position + 1].									continue := false]]]].	cToken_cHit := cToken_cHit collect: [:acHit | self compactcHit: acHit].</body><body package="ASKOH">at: aToken	^cToken_cHit at: aToken.</body><body package="ASKOH">cToken	^cToken_cHit keys.</body><body package="ASKOH">cToken_cHit	^cToken_cHit.</body><body package="ASKOH">cToken_cHit: anObject	cToken_cHit := anObject.</body><body package="ASKOH">classname	^classname.</body><body package="ASKOH">classname: anObject	classname := anObject.</body><body package="ASKOH">compactcHit: cHit	| nPos |	nPos := cHit size.	^nPos = 1		ifTrue: [cHit first]		ifFalse: 			[nPos = 2				ifTrue: 					[(cHit allSatisfy: [:pos | pos &lt; TwoRaisedTo12])						ifTrue: [(cHit at: 1) * TwoRaisedTo12 + (cHit at: 2)]						ifFalse: [self aWordArrayFrom: cHit]]				ifFalse: [(cHit allSatisfy: [:pos | pos &lt; 256]) ifTrue: [self aByteArrayFrom: cHit] ifFalse: [self aWordArrayFrom: cHit]]].</body><body package="ASKOH">nOccurrenceOf: aToken	| cHit |	cHit := cToken_cHit at: aToken.	^cHit isInteger		ifTrue: [cHit &lt; TwoRaisedTo12 ifTrue: [1] ifFalse: [2]]		ifFalse: [cHit size].</body><body package="ASKOH">selector	^selector.</body><body package="ASKOH">selector: anObject	selector := anObject.</body><body package="ASKOH">tokensDo: aBlock	cToken_cHit keysDo: aBlock.</body><body package="ASKOH">xaMethod: aCompiledMethod	classname := aCompiledMethod mclass fullName asSymbol.	selector := aCompiledMethod selector.	aCompiledMethod getSource		ifNotNil: [:aText | self addSource: aText]		ifNil: 			[aCompiledMethod decompiledSource				ifNotNil: [:aText | self addSource: aText]				ifNil: [self halt: 'no source code.']].</body></methods><methods><class-id>SearchMethod2</class-id> <category>testing</category><body package="ASKOH">includesKey: aToken	^cToken_cHit includesKey: aToken.</body><body package="ASKOH">includesKeyLike: searchToken	cToken_cHit		keysDo: [:methodToken | (searchToken match: methodToken) ifTrue: [^true]].	^false.</body><body package="ASKOH">isAccepted: char	^char isSeparator not.</body></methods><methods><class-id>SearchMethod2 class</class-id> <category>class initialization</category><body package="ASKOH">initialize	TwoRaisedTo12 := 2 raisedTo: 12.</body></methods><methods><class-id>SearchMethod2 class</class-id> <category>instance creation</category><body package="ASKOH">with: aCompiledMethod	^(super new)		xaMethod: aCompiledMethod;		yourself.</body></methods><methods><class-id>Refactory.Browser.BrowserPrintHierarchyTool</class-id> <category>aspects</category><body package="ASKOH">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Refactory.Browser.BrowserPrintHierarchyTool</class-id> <category>updating</category><body package="ASKOH">updateContents    self text value: codeModel classOrNameSpace printHierarchy.</body></methods><methods><class-id>Refactory.Browser.BrowserPrintHierarchyTool</class-id> <category>tab management</category><body package="ASKOH">isActive	^self classOrNameSpace notNil</body><body package="ASKOH">tabName	^'Print Hierarchy'</body></methods><methods><class-id>MessageForwarder</class-id> <category>initialize-release</category><body package="ASKOH">_initializeWith: anObject	object := anObject</body></methods><methods><class-id>MessageForwarder</class-id> <category>accessing</category><body package="ASKOH">_object	^object</body></methods><methods><class-id>MessageForwarder</class-id> <category>testing</category><body package="ASKOH">_isForwarder	^true</body></methods><methods><class-id>MessageForwarder</class-id> <category>error handling</category><body package="ASKOH">doesNotUnderstand: aMessage	Transcript		cr;		print: aMessage.	^self _forwardMessage: aMessage</body></methods><methods><class-id>MessageForwarder</class-id> <category>private</category><body package="ASKOH">_forwardMessage: aMessage	^object perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>MessageForwarder class</class-id> <category>instance creation</category><body package="ASKOH">with: anObject	^self new _initializeWith: anObject</body></methods><methods><class-id>SearchSmalltalk2</class-id> <category>accessing</category><body package="ASKOH">addMethod: aCompiledMethod	| aSearchMethod cMethod |	aSearchMethod := SearchMethod2 with: aCompiledMethod.	aSearchMethod tokensDo: 			[:token |			cMethod := cToken_cMethod at: token ifAbsentPut: [SearchToken2 with: token].			cMethod add: aSearchMethod].</body><body package="ASKOH">cAllClass	^cClassToBeIndexed.</body><body package="ASKOH">cAllClass: cClass	cClassToBeIndexed := cClass.</body><body package="ASKOH">cSearchMethodLike: cToken	"Singleton cSearchMethodLike: #(#'put*' #'*string*').Singleton cSearchMethodLike: #(#'*put*' #'string*')."	| cSymbol cSearchMethod searchToken |	cSymbol := cToken collect: [:a | a asSymbol].	cSymbol sortWith: 			[:a :b |			| naStar nbStar |			naStar := a occurrencesOf: $*.			nbStar := b occurrencesOf: $*.			naStar = nbStar ifTrue: [a size &lt;= b size] ifFalse: [naStar &lt;= nbStar]].	cSearchMethod := Set new: 100.	searchToken := cSymbol first.	(searchToken occurrencesOf: $*) = 0		ifTrue: 			[cSearchMethod				addAll: (cToken_cMethod at: searchToken ifAbsent: [Array new])]		ifFalse: 			[cToken_cMethod keysAndValuesDo: 					[:token :cMethod |					(searchToken match: token) ifTrue: [cSearchMethod addAll: cMethod]]].	2 to: cSymbol size		do: 			[:i |			searchToken := cSymbol at: i.			cSearchMethod := (searchToken occurrencesOf: $*) = 0						ifTrue: 							[cSearchMethod								select: [:aSearchMethod | aSearchMethod includesKey: searchToken]]						ifFalse: 							[cSearchMethod								select: [:aSearchMethod | aSearchMethod includesKeyLike: searchToken]]].	^cSearchMethod.</body><body package="ASKOH">cSearchMethodSatisfyAll: cToken	"Singleton cSearchMethodSatisfyAll: #(#'put*' #'*string*').Singleton cSearchMethodSatisfyAll: #(#'*put*' #'string*')."	| cSymbol cSearchMethod searchToken |	cSymbol := cToken collect: [:a | a asSymbol].	cSymbol sortWith: 			[:a :b |			| naStar nbStar |			naStar := a occurrencesOf: $*.			nbStar := b occurrencesOf: $*.			naStar = nbStar ifTrue: [a size &lt;= b size] ifFalse: [naStar &lt;= nbStar]].	cSearchMethod := Set new: 100.	searchToken := cSymbol first.	(searchToken occurrencesOf: $*) = 0		ifTrue: [cSearchMethod addAll: (cToken_cMethod at: searchToken ifAbsent: [Array new])]		ifFalse: [cToken_cMethod keysAndValuesDo: [:token :cMethod | (searchToken match: token) ifTrue: [cSearchMethod addAll: cMethod]]].	2 to: cSymbol size		do: 			[:i |			searchToken := cSymbol at: i.			cSearchMethod := (searchToken occurrencesOf: $*) = 0						ifTrue: [cSearchMethod select: [:aSearchMethod | aSearchMethod includesKey: searchToken]]						ifFalse: [cSearchMethod select: [:aSearchMethod | aSearchMethod includesKeyLike: searchToken]]].	^cSearchMethod.</body><body package="ASKOH">cSearchMethodSatisfyAny: cToken	"Singleton cSearchMethodSatisfyAny: #(#'put*' #'*string*').Singleton cSearchMethodSatisfyAny: #(#'*put*' #'string*')."	| ccToken cSearchMethod |	ccToken := cToken collect: [:a | Array with: a].	cSearchMethod := Singleton cSearchMethodSatisfyAll: ccToken first.	2 to: ccToken size do: [:i | cSearchMethod addAll: (Singleton cSearchMethodSatisfyAll: (ccToken at: i))].	^cSearchMethod.</body><body package="ASKOH">cSearchMethodWith: cToken	"Singleton cSearchMethodWith: #(#put #string)."	| cSymbol |	cSymbol := cToken collect: [:a | a asSymbol].	^cToken_cMethod		at: cSymbol first		ifPresent: 			[:aSearchToken |			| cSearchMethod |			cSearchMethod := aSearchToken cSearchMethod shallowCopy.			2 to: cSymbol size do: [:i | cSearchMethod := cSearchMethod select: [:aSearchMethod | aSearchMethod includesKey: (cSymbol at: i)]].			cSearchMethod]		ifAbsent: [OrderedCollection new].</body><body package="ASKOH">cToken_cMethod	^cToken_cMethod.</body><body package="ASKOH">cToken_cMethod: anObject	cToken_cMethod := anObject.</body></methods><methods><class-id>SearchSmalltalk2</class-id> <category>ops</category><body package="ASKOH">indexAllMethods	cClassToBeIndexed do: 			[:aClass |			aClass cAllMethod do: [:aMethod | self addMethod: aMethod].			aClass class cAllMethod do: [:aMethod | self addMethod: aMethod]].</body><body package="ASKOH">removeWeirdTokens	"Singleton removeWierdTokens."	| newcToken_cMethod nChar |	newcToken_cMethod := cToken_cMethod species new: cToken_cMethod size / 2.	cToken_cMethod keysAndValuesDo: 			[:token :cMethod |			nChar := token size.			((nChar &gt;= 2 and: [nChar &lt;= 8])				or: [(token allSatisfy: [:char | char isAlphaNumeric]) or: [nChar &lt;= 64 and: [token anySatisfy: [:char | char isAlphaNumeric]]]])					ifTrue: [newcToken_cMethod at: token put: cMethod]].	cToken_cMethod := newcToken_cMethod.</body></methods><methods><class-id>SearchSmalltalk2</class-id> <category>initialize-release</category><body package="ASKOH">initialize	cToken_cMethod := IdentityDictionary new.</body></methods><methods><class-id>SearchSmalltalk2 class</class-id> <category>instance creation</category><body package="ASKOH">indexAllMethods	"[self indexAllMethods] minutesToRun inspect."	Singleton := (self new)				cAllClass: (Array with: Array with: Search);				indexAllMethods;				yourself.	"(Array with: Array with: Search) do: [:aClass | Singleton addClass: aClass]"</body><body package="ASKOH">indexAllMethods0	"This has infinite loop![self indexAllMethods0] minutesToRun inspect."	Singleton := (self new)				cAllClass: (Array with: ASKOH);				indexAllMethods;				yourself</body><body package="ASKOH">indexAllMethods1	"[self indexAllMethods1] minutesToRun inspect."	Singleton := (self new)				cAllClass: (Array with: Array with: Object);				indexAllMethods;				yourself.	"(Array with: Array with: Search) do: [:aClass | Singleton addClass: aClass]"</body><body package="ASKOH">indexAllMethods2	"[self indexAllMethods2] minutesToRun inspect."	| excludedClasses |	excludedClasses := (OrderedCollection new)				add: ASKOH;				yourself.	Singleton := (self new)				cAllClass: (Root allClasses reject: [:a | excludedClasses includes: a]);				indexAllMethods;				yourself</body></methods><methods><class-id>SearchSmalltalk2 class</class-id> <category>utilities</category><body package="ASKOH">browseMethodsSatisfyAll: cToken	"Order of tokens is not considered.[self browseMethodsSatisfyAll: #('*cycle*')] secondsToRun.[self browseMethodsSatisfyAll: #('*id2*')] secondsToRun.[self browseMethodsSatisfyAll: #('*non*grid*')] secondsToRun.[self browseMethodsSatisfyAll: #('*string*' '*put*')] secondsToRun.[self browseMethodsSatisfyAll: #('put*' '*string*')] secondsToRun.[self browseMethodsSatisfyAll: #('*string*' 'put*')] secondsToRun.[self browseMethodsSatisfyAll: #('put' '*string*')] secondsToRun.[self browseMethodsSatisfyAll: #('*string*' 'put')] secondsToRun.[self browseMethodsSatisfyAll: #('put' 'string')] secondsToRun.[self browseMethodsSatisfyAll: #('string' 'put')] secondsToRun."	| cSearchMethod cMethodDefinition |	cSearchMethod := Singleton cSearchMethodSatisfyAll: cToken.	cMethodDefinition := cSearchMethod collect: [:a | a aMethodDefinition].	MethodCollector new openListBrowserOn: cMethodDefinition label: 'Methods with ' , cToken printString.</body><body package="ASKOH">browseMethodsSatisfyAny: cToken	"[self browseMethodsSatisfyAny: #('*put*' '*string*')] secondsToRun.[self browseMethodsSatisfyAny: #('*string*' '*put*')] secondsToRun.[self browseMethodsSatisfyAny: #('put*' '*string*')] secondsToRun.[self browseMethodsSatisfyAny: #('*string*' 'put*')] secondsToRun.[self browseMethodsSatisfyAny: #('put' '*string*')] secondsToRun.[self browseMethodsSatisfyAny: #('*string*' 'put')] secondsToRun.[self browseMethodsSatisfyAny: #('put' 'string')] secondsToRun.[self browseMethodsSatisfyAny: #('string' 'put')] secondsToRun."	| cSearchMethod cMethodDefinition |	cSearchMethod := Singleton cSearchMethodSatisfyAny: cToken.	cMethodDefinition := cSearchMethod collect: [:a | a aMethodDefinition].	MethodCollector new openListBrowserOn: cMethodDefinition label: 'Methods with ' , cToken printString.</body><body package="ASKOH">commands	"SearchItem singleton.SearchItem singleton: nil.ObjectMemory verboseGlobalCompactingGC.SystemAnalyzer new byteSizeOfObject: SearchToken allInstances firstSystemAnalyzer new byteSizeOfObject: '123456'SystemAnalyzer new byteSizeOfObject: #symbolsSystemAnalyzer new byteSizeOfObject: #(1 2 3 4 5)SystemAnalyzer new byteSizeOfObject: IdentityDictionary newSearchToken allInstancesSearchClass allInstancesSearchMethod allInstancesSearchSmalltalk2 indexAllMethods1SearchSmalltalk2 index_nMethod: 2000iMax = 1000nToken = 463166nClass = 998nMethod = 57626iMax = 2000nToken = 998376nClass = 1998nMethod = 120542"</body><body package="ASKOH">nMethod	"[self nMethod] minutesToRun inspect."	| nMethod i iMax iDelta |	nMethod := 0.	i := 0.	iMax := 1000.	iDelta := iMax // 10.	SystemUtils allBehaviorsDo: 			[:aClass |			i := i + 1.			i \\ iDelta = 0				ifTrue: 					[Transcript						cr;						show: i].			i &lt;= iMax				ifTrue: 					[nMethod := nMethod + aClass methodDictionary size.					nMethod := nMethod + aClass class methodDictionary size]].	^nMethod.</body><body package="ASKOH">readTopIndex	"[self readTopIndex] minutesToRun inspect."	| bosFile |	bosFile := BinaryObjectStorage onOldNoScan: 'C:\_tms\envs\devC\clientDeveloper\searchTopIndex.bos' asFilename readStream.	[Singleton := bosFile next] ensure: [bosFile close].	^Singleton.</body><body package="ASKOH">saveTopIndex	"	[self saveTopIndex] minutesToRun inspect.	"	| bosFile |	bosFile := BinaryObjectStorage onNew: 'searchTopIndex.bos' asFilename writeStream.	[bosFile nextPut: Singleton] ensure: [bosFile close].</body><body package="ASKOH">showFoundFor: cString	"SearchSmalltalk2 showFoundFor: #(put DailyPlan_PDDPacketsInjectionWithdraw_Get DailyPlan_SBAPeakPackDraft_Get)"	| keys index continue key size |	keys := Singleton cToken_cMethod keys asArray.	size := keys size.	cString do: 			[:aString |			index := 0.			continue := true.						[index := index + 1.			index &lt;= size				ifTrue: 					[key := keys at: index.					(key indexOfSubCollection: aString) &gt; 0						ifTrue: 							[Transcript								cr;								show: ('&lt;1s&gt; ---- &lt;2s&gt;' expandMacrosWith: aString with: key).							continue := false]]				ifFalse: [continue := false].			continue]					whileTrue].</body></methods><methods><class-id>Search</class-id> <category>_make index</category><body package="ASKOH">_addClass: aClass toIndex: dAllTokenSymbol	"	self new _addClass: Search toIndex:  IdentityDictionary new.	"	aClass cAllMethod do: [:each | self _addMethod: each toIndex: dAllTokenSymbol].	^dAllTokenSymbol.</body><body package="ASKOH">_addMethod: aCompiledMethod toIndex: dAllTokenSymbol	"	self new _addMethod: self new _exampleMethod toIndex: IdentityDictionary new.	"	| cTokenSymbol |	aCompiledMethod getSource		ifNotNil: 			[:source |			cTokenSymbol := self breakIntoTokenSymbols: source.			cTokenSymbol do: [:each | self _addMethod: aCompiledMethod toIndex: dAllTokenSymbol atToken: each]].	^dAllTokenSymbol.</body><body package="ASKOH">_addMethod: aCompiledMethod toIndex: dAllTokenSymbol atToken: aByteSymbol	| dMethod dTokenDoc |	dMethod := dAllTokenSymbol at: aByteSymbol ifAbsentPut: IdentityDictionary new.	dTokenDoc := dMethod at: aCompiledMethod ifAbsentPut: IdentityDictionary new.	dTokenDoc at: aByteSymbol put: nil.</body></methods><methods><class-id>Search</class-id> <category>_search token</category><body package="ASKOH">_searchIndex: dAllTokenSymbol forPattern: aPattern	"	| index search |	index := IdentityDictionary new.	search := Search new.	search _addClass: Search toIndex: index.	search _searchIndex: index forPattern: '*browse*'	'*browse*' match: #_browseAll	"	| cResultMethods cMethods cToken |	cResultMethods := List new.	cToken := dAllTokenSymbol keys select: [:each | aPattern match: each].	cToken do: 			[:each |			cMethods := self _searchIndex: dAllTokenSymbol forToken: each.			cResultMethods addAll: cMethods].	^cResultMethods.</body><body package="ASKOH">_searchIndex: dAllTokenSymbol forToken: aToken	"	| index search |	index := IdentityDictionary new.	search := Search new.	search _addClass: Search toIndex: index.	search _searchIndex: index forToken: #searchString.	"	| dMethod |	dMethod := dAllTokenSymbol at: aToken.	^dMethod keys.</body></methods><methods><class-id>Search</class-id> <category>_browse</category><body package="ASKOH">_browseIndex: dAllTokenSymbol forPattern: aPattern	"	| index search |	index := IdentityDictionary new.	search := Search new.	search _addClass: Search toIndex: index.	search _browseIndex: index forPattern: 'search*'	"	| cMethod cMethodDefinition |	cMethod := self _searchIndex: dAllTokenSymbol forPattern: aPattern.	cMethodDefinition := self _asDefinitions: cMethod.	self _browseMethods: cMethodDefinition searchString: aPattern.</body><body package="ASKOH">_browseIndex: dAllTokenSymbol forToken: aToken	"	| index search |	index := IdentityDictionary new.	search := Search new.	search _addClass: Search toIndex: index.	search _browseIndex: index forToken: #index	"	| cMethod cMethodDefinition |	cMethod := self _searchIndex: dAllTokenSymbol forToken: aToken.	cMethodDefinition := self _asDefinitions: cMethod.	self _browseMethods: cMethodDefinition searchString: aToken.</body><body package="ASKOH">_browseMethods: cMethodDefinitions searchString: aString	Refactory.Browser.RefactoringBrowser		openListBrowserOn: cMethodDefinitions		label: 'FIND STRING ' , aString		initialSelection: aString.</body></methods><methods><class-id>Search</class-id> <category>_utility</category><body package="ASKOH">_asDefinitions: cCompiledMethod	^cCompiledMethod collect: [:each | (each isKindOf: CompiledMethod) ifTrue: [each definition] ifFalse: [each]].</body></methods><methods><class-id>Search</class-id> <category>utilities</category><body package="ASKOH">_cAllTokenSymbol	"	self new cAllTokenSymbol.	"	| cAllTokenSymbol cTokenSymbol |	cAllTokenSymbol := IdentityDictionary new.	self cAllMethod do: 			[:aMethod |			aMethod getSource				ifNotNil: 					[:source |					cTokenSymbol := self breakIntoTokenSymbols: source.					cTokenSymbol do: [:a | self addMethod: aMethod toIndex: cAllTokenSymbol atToken: a]]].	^cAllTokenSymbol.</body><body package="ASKOH">breakIntoTokenSymbols1: textOrString	"Search new breakIntoTokenSymbols: (Scanner sourceCodeAt: #breakIntoTokenSymbols:)"	| substrings aString aReadStream char subStream continue |	substrings := OrderedCollection new: textOrString size // 4.	aString := textOrString string.	aReadStream := aString readStream.	[aReadStream atEnd] whileFalse: 			[char := aReadStream next.			char isSeparator				ifFalse: 					[subStream := WriteStream on: String new.					subStream nextPut: char.					continue := true.					[continue and: [aReadStream atEnd not]] whileTrue: 							[char := aReadStream next.							char isSeparator								ifTrue: 									[substrings add: subStream contents asSymbol.									continue := false]								ifFalse: [subStream nextPut: char]]]].	^substrings.</body><body package="ASKOH">breakIntoTokenSymbols: textOrString	"Search new breakIntoTokenSymbols: (Scanner sourceCodeAt: #breakIntoTokenSymbols:)"	| substrings aString aReadStream char subStream continue |	substrings := OrderedCollection new: textOrString size // 4.	aString := textOrString string.	aReadStream := aString readStream.	[aReadStream atEnd] whileFalse: 			[char := aReadStream next.			char isAlphaNumeric				ifTrue: 					[subStream := WriteStream on: String new.					subStream nextPut: char.					continue := true.					[continue and: [aReadStream atEnd not]] whileTrue: 							[char := aReadStream next.							char isAlphaNumeric								ifTrue: [subStream nextPut: char]								ifFalse: 									[substrings add: subStream contents asSymbol.									continue := false]]]].	^substrings.</body><body package="ASKOH">cAllMethod	| cAllMethod |	cAllMethod := List new.	SystemUtils		allBehaviorsDo: [:aClass | cAllMethod addAll: aClass cAllMethod].	^cAllMethod.</body><body package="ASKOH">cAllTokenSymbol	"	self new cAllTokenSymbol.	"	| cAllTokenSymbol cTokenSymbol |	cAllTokenSymbol := IdentityDictionary new.	self cAllMethod do: 			[:aMethod |			aMethod getSource				ifNotNil: 					[:source |					cTokenSymbol := self breakIntoTokenSymbols: source.					cTokenSymbol do: [:a | cAllTokenSymbol at: a put: nil]]].	^cAllTokenSymbol.</body><body package="ASKOH">cAllTokenSymbol1	"	self new cAllTokenSymbol.	"	| cAllTokenSymbol cTokenSymbol |	cAllTokenSymbol := IdentityDictionary new.	self cAllMethod do: 			[:aMethod |			aMethod getSource				ifNotNil: 					[:source |					cTokenSymbol := self breakIntoTokenSymbols: source.					cTokenSymbol do: [:a | cAllTokenSymbol at: a put: nil]]].	^cAllTokenSymbol.</body><body package="ASKOH">cClassMatching: matchString	"	self new cClassMatching: '*print*'.	"	| cClass |	cClass := List new.	SystemUtils allBehaviorsDo: [:aClass | (matchString match: aClass name) ifTrue: [cClass add: aClass]].	^cClass.</body><body package="ASKOH">cClassWithInstanceVariableMatching: matchString	"self new cClassWithInstanceVariableMatching: '*print*'."	| cClass |	cClass := List new.	SystemUtils allBehaviorsDo: 			[:aClass |			(aClass instVarNames anySatisfy: [:name | matchString match: name])				ifTrue: [cClass add: aClass]].	^cClass.</body><body package="ASKOH">cMethodMatching: matchString	"	self new cMethodMatching: '*print*'.	"	| cMethod |	cMethod := List new.	SystemUtils		allBehaviorsDo: [:aClass | cMethod addAll: (aClass cMethodMatching: matchString)].	^cMethod.</body><body package="ASKOH">commands	self new searchAll: '*(0 1 2 5)*'.	ImageConfigurationSystem new tokensFromStream: 'adfa 54 %$%^ :=' readStream.	Scanner new breakIntoTokens: (Scanner sourceCodeAt: #breakIntoTokens:).	DiffList breakIntoTokens: (Scanner sourceCodeAt: #breakIntoTokens:).	Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' embedded.period key:word: .   '.</body><body package="ASKOH">searchAll: aByteString	"	(self searchNamespace: aByteString) inspect.	(self searchPackage: aByteString) inspect.	(self searchBundle: aByteString) inspect.	(self searchClass: aByteString) inspect.	(self searchMethod: aByteString) inspect.	(self searchPool: aByteString) inspect.	(self searchComment: aByteString) inspect."	"	self new searchAll: '*(0 1 2 5)*'."	| compiledMethodCollection methodDefinitionCollection |	compiledMethodCollection := List new.	SystemUtils allBehaviorsDo: 			[:eachClass |			self				searchClass: eachClass				forString: aByteString				into: compiledMethodCollection].	methodDefinitionCollection := compiledMethodCollection				collect: [:each | each definition].	Refactory.Browser.RefactoringBrowser		openListBrowserOn: methodDefinitionCollection		label: 'FIND STRING ' , aByteString		initialSelection: aByteString.	^compiledMethodCollection.</body><body package="ASKOH">searchClass: aClass forString: matchString into1: aCollection	aClass selectorsAndMethodsDo: 			[:selector :aCompiledMethod |			| source |			source := aCompiledMethod getSource						ifNil: [aCompiledMethod decompiledSource].			(matchString match: source) ifTrue: [aCollection add: aCompiledMethod]].</body><body package="ASKOH">searchClass: aClass forString: matchString into: aCollection	aClass selectorsAndMethodsDo: 			[:selector :aCompiledMethod |			aCompiledMethod getSource ifNotNil: [:source | (matchString match: source) ifTrue: [aCollection add: aCompiledMethod]]].</body><body package="ASKOH">searchForDuplicateCompiledMethods	"self new searchForDuplicateCompiledMethods."	| byCompilationResult aDict nMethod |	nMethod := 0.	byCompilationResult := Dictionary new.	Smalltalk enumerateMethods: 			[:behavior :selector :compiled |			| key |			nMethod := nMethod + 1.			key := Array						with: selector						with: compiled bytes						with: compiled literals.			(byCompilationResult at: key ifAbsentPut: [OrderedCollection new]) add: compiled definition].	byCompilationResult := (byCompilationResult reject: [:set | set size = 1]) collect: #asArray.	Transcript		cr;		show: ('nMethod := &lt;1p&gt;' expandMacrosWith: nMethod).	aDict := Dictionary new.	byCompilationResult do: [:a | aDict at: a first method getSource string asSymbol put: a].	aDict inspect.</body><body package="ASKOH">searchForDuplicateMethods	"self new searchForDuplicateMethods."	| bySourceResult |	bySourceResult := Dictionary new.	Smalltalk enumerateMethods: 			[:behavior :selector :compiled |						[| key |			key := Scanner new scanTokens: compiled getSource.			(bySourceResult at: key ifAbsentPut: [OrderedCollection new]) add: compiled definition]					on: Error					do: 						[:ex |						Transcript							cr;							show: ex errorString;							space;							show: compiled definition printString]].	bySourceResult := (bySourceResult reject: [:c | c size = 1]) collect: #asArray.	bySourceResult inspect.</body></methods><methods><class-id>Search</class-id> <category>_search string</category><body package="ASKOH">_searchClass: aClass forString: aString	"	self new _searchClass: Search forString: '*aString*'	"	| compiledMethodCollection methodDefinitionCollection |	compiledMethodCollection := List new.	self searchClass: aClass forString: aString into: compiledMethodCollection.	methodDefinitionCollection := compiledMethodCollection collect: [:each | each definition].	self _browseMethods: methodDefinitionCollection searchString: aString.</body></methods><methods><class-id>ASKOH</class-id> <category>utilities</category><body package="ASKOH">browseFilenamesMatching: aFilenameString	"self new browseFilenamesMatching: '\\nndes-aptms3p\ftp\conf\archive\*\*784900_007947385*' "	| cFilenameString aFileList builder |	cFilenameString := (self cFilenameMatching: aFilenameString) collect: [:a | a asString].	aFileList := FileBrowser new.	aFileList list: cFilenameString.	aFileList pattern: aFilenameString.	builder := aFileList allButOpenInterface: #windowSpec.	builder openWithExtent: 800 @ 700.	aFileList postOpenWith: builder.	builder window label: 'Files containing: *' printString.</body><body package="ASKOH">browseFilenamesMatching: aFilenameString containingAll: cSearchString	"self new browseFilenamesMatching: '\\nndes-aptms3p\ftp\nom\archive\req\backup\072011\*\*809024784*' containingAll: #('*118603*' '*109721*')"	| cFilenameString aFileList builder |	cFilenameString := (self cFilenameMatching: aFilenameString containingAll: cSearchString) collect: [:a | a asString].	aFileList := FileBrowser new.	aFileList list: cFilenameString.	aFileList pattern: aFilenameString.	builder := aFileList allButOpenInterface: #windowSpec.	builder openWithExtent: 800 @ 700.	aFileList postOpenWith: builder.	builder window label: 'Files containingAll: ' , cSearchString printString.</body><body package="ASKOH">browseFilenamesMatching: aFilenameString containingAny: cSearchString	"self new browseFilenamesMatching: '\\nndes-aptms3p\ftp\nom\archive\req\backup\072011\*\*809024784*' containingAny: #('*118603*' '*109721*')"	| cFilenameString aFileList builder |	cFilenameString := (self cFilenameMatching: aFilenameString containingAny: cSearchString) collect: [:a | a asString].	aFileList := FileBrowser new.	aFileList list: cFilenameString.	aFileList pattern: aFilenameString.	builder := aFileList allButOpenInterface: #windowSpec.	builder openWithExtent: 800 @ 700.	aFileList postOpenWith: builder.	builder window label: 'Files containingAny: ' , cSearchString printString.</body><body package="ASKOH">browseFilenamesRecursively: aDirectoryString matching: aNameString	"self new browseFilenamesRecursively: '\\nndes-aptms3p\ftp\conf\archive\reqin\backup\012014' matching: '*007947385*'"	| cFilenameString aFileList builder |	cFilenameString := (self cFilenameRecursively: aDirectoryString matching: aNameString) collect: [:a | a asString].	aFileList := FileBrowser new.	aFileList list: cFilenameString.	aFileList pattern: aNameString.	builder := aFileList allButOpenInterface: #windowSpec.	builder openWithExtent: 800 @ 700.	aFileList postOpenWith: builder.	builder window label: 'Files containing: *' printString.</body><body package="ASKOH">browseMethodsSatisfying: aBlock	"self new browseMethodsSatisfying: [:m | (m respondsTo: #selector) and: ['*getScheduledQuantitiesContractNumber:*' match: m selector]].self new browseMethodsSatisfying: [:c :s :m | s notNil and: ['*getScheduledQuantitiesContractNumber:*' match: s]]."	| aMethodFilterSelect |	aMethodFilterSelect := (MethodFilterSelect new)				block: aBlock;				yourself.	MethodCollector new browseSelect: aMethodFilterSelect.</body><body package="ASKOH">browseMethodsWithSourceMatching: wildcardString	"self new browseMethodsWithSourceMatching: '*paint*'.[self new browseMethodsWithSourceMatching: '*paint*'] minutesToRun."	self browseMethodsSatisfying: 			[:m |			| source |			(source := m getSource) notNil and: [wildcardString match: source]].</body><body package="ASKOH">browseRecursiveSendersOf: aSymbol	"self new browseRecursiveSendersOf: #painter.Beware of exponential growth."	| mc allSymbol cSymbol cNextLevelSender cSender |	allSymbol := OrderedSet new.	mc := MethodCollector new.	cSymbol := OrderedSet with: aSymbol.		[cNextLevelSender := OrderedSet new.	cSymbol do: 			[:symbol |			cSender := mc select: (mc referencesTo: symbol).			cSender do: 					[:sender |					(allSymbol includes: sender) not						ifTrue: 							[allSymbol add: sender.							cNextLevelSender add: sender]]].	cSymbol := cNextLevelSender collect: [:a | a selector].	cSymbol notEmpty]			whileTrue.	allSymbol inspect.</body><body package="ASKOH">browseSendersOf: aSymbol	"self new browseSendersOf: #paint:."	| mc |	mc := MethodCollector new.	mc browseSelect: (mc referencesTo: aSymbol).</body><body package="ASKOH">cFilenameMatching: aFilenameString	"self new cFilenameMatching: '\\nndes-aptms3p\ftp\nom\archive\req\backup\072011\0704\*809024784*' "	| cFilename |	cFilename := (Filename filesMatching: aFilenameString) collect: [:a | a asFilename].	^cFilename select: [:a | a isDirectory not].</body><body package="ASKOH">cFilenameMatching: aFilenameString containingAll: cSearchString	"self new cFilenameMatching: '\\nndes-aptms3p\ftp\nom\archive\req\backup\072011\0704\*809024784*' containingAll: #('*118603*' '*109721*')"	| cFilename cSelectedFilename readStream aString |	cFilename := (Filename filesMatching: aFilenameString) collect: [:a | a asFilename].	cFilename := cFilename select: [:a | a isDirectory not].	cSelectedFilename := cSearchString isEmpty				ifTrue: [cFilename]				ifFalse: 					[cFilename select: 							[:a |							readStream := a readStream.							[aString := readStream contents] ensure: [readStream close].							cSearchString allSatisfy: [:ax | ax match: aString]]].	^cSelectedFilename.</body><body package="ASKOH">cFilenameMatching: aFilenameString containingAny: cSearchString	"self new cFilenameMatching: '\\nndes-aptms3p\ftp\nom\archive\req\backup\072011\0704\*809024784*' containingAny: #('*118603*' '*109721*')"	| cFilename cSelectedFilename readStream aString |	cFilename := (Filename filesMatching: aFilenameString) collect: [:a | a asFilename].	cFilename := cFilename select: [:a | a isDirectory not].	cSelectedFilename := cSearchString isEmpty				ifTrue: [cFilename]				ifFalse: 					[cFilename select: 							[:a |							readStream := a readStream.							[aString := readStream contents] ensure: [readStream close].							cSearchString anySatisfy: [:ax | ax match: aString]]].	^cSelectedFilename.</body><body package="ASKOH">cFilenameRecursively: aDirectoryString matching: aNameString	"self new cFilenameRecursively: '\\nndes-aptms3p\ftp\conf\archive\reqin\backup\012014' matching: '*784900_007947385*'"	| cFilename |	cFilename := aDirectoryString asFilename directoryContentsRecursively collect: [:a | a asFilename].	^cFilename select: [:a | a isDirectory not and: [aNameString match: a asString]].</body><body package="ASKOH">copyFiles: matchString fromDir: fromDir toDir: toDir	"self new copyFiles: '*.st' fromDir: 'C:\_tms\envs\devC\servers\chg_setsDummy' toDir: 'C:\_tms\envs\devC\servers\port4235\chg_sets'."	| fromDirFilename toDirFilename cFile fromFilename toFilename |	fromDirFilename := fromDir asFilename.	toDirFilename := toDir asFilename.	cFile := fromDirFilename directoryContents select: [:each | (fromDirFilename construct: each) isDirectory ifFalse: [matchString match: each]].	cFile do:		[:each | 		fromFilename := fromDirFilename construct: each.		toFilename := toDirFilename construct: each.		[fromFilename copyTo: toFilename]			on: Error			do:				[:ex | 				Transcript show:					('&lt;n&gt;Cannot copy &lt;1s&gt; to: &lt;2s&gt;&lt;n&gt;&lt;3s&gt;'						expandMacrosWith: fromFilename asString						with: toFilename asString						with: ex message)]].</body><body package="ASKOH">deleteFiles: matchString fromDir: fromDir	"self new deleteFiles: '*.st' fromDir: 'C:\_tms\envs\devC\servers\chg_setsDummy'."	| fromDirFilename cFile fromFilename |	fromDirFilename := fromDir asFilename.	cFile := fromDirFilename directoryContents select: [:each | (fromDirFilename construct: each) isDirectory ifFalse: [matchString match: each]].	cFile do:		[:each | 		fromFilename := fromDirFilename construct: each.		[fromFilename delete]			on: Error			do:				[:ex | 				Transcript show:					('&lt;n&gt;Cannot delete &lt;1s&gt;.&lt;n&gt;&lt;2s&gt;'						expandMacrosWith: fromFilename asString						with: ex message)]].</body><body package="ASKOH">loadASKOH	"self new loadASKOH."	| access recentProfile connection cASKOH |	access := Store.DbRegistry.	recentProfile := access instVarAt: (access class instVarIndexFor: 'recentProfile').	connection := access instVarAt: (access class instVarIndexFor: 'connection').	access isConnected		ifFalse: 			[access connectionOrNil.			connection isNil ifTrue: [access connectTo: recentProfile]].	cASKOH := Store.Package allVersionsWithName: 'ASKOH'.	cASKOH notEmpty ifTrue: [cASKOH first loadSrc].	access closeConnection.	access connectionOrNil.	Refactory.Browser.RefactoringBrowser newOnClass: ASKOH.</body><body package="ASKOH">lookForDuplicateObjectInCollection: aCollection	"self new lookForDuplicateObjectInCollection: #(1 2 3 4 5 6 5 4)"	^self		lookForDuplicateObjectInCollection: aCollection		basedOn: [:a | a].</body><body package="ASKOH">lookForDuplicateObjectInCollection: aCollection basedOn: aBlock	"self new lookForDuplicateObjectInCollection: #(1 2 3 4 5 6 5 4) basedOn: [:a | a]"	| cCriterion ccDup n iCriterion cDup jCriterion |	cCriterion := aCollection collect: aBlock.	ccDup := OrderedCollection new.	n := aCollection size.	1		to: n		do:			[:i | 			iCriterion := cCriterion at: i.			iCriterion ifNotNil:				[cDup := OrderedCollection new.				cDup add: (aCollection at: i).				i + 1					to: n					do:						[:j | 						jCriterion := cCriterion at: j.						jCriterion ifNotNil:							[iCriterion = jCriterion ifTrue:								[cDup add: (aCollection at: j).								cCriterion at: j put: nil]]].				cDup size &gt; 1 ifTrue: [ccDup add: cDup]]].	^ccDup.</body></methods><methods><class-id>SearchToken2</class-id> <category>accessing</category><body package="ASKOH">add: aSearchItem	nOccurrence := nOccurrence + (aSearchItem nOccurrenceOf: token).	^cSearchMethod add: aSearchItem.</body><body package="ASKOH">cSearchMethod	^cSearchMethod.</body><body package="ASKOH">cSearchMethod: anObject	cSearchMethod := anObject.</body><body package="ASKOH">nOccurrence	^nOccurrence.</body><body package="ASKOH">nOccurrence: anObject	nOccurrence := anObject.</body><body package="ASKOH">token	^token.</body><body package="ASKOH">token: anObject	token := anObject.</body></methods><methods><class-id>SearchToken2</class-id> <category>enumeration</category><body package="ASKOH">do: aBlock	cSearchMethod do: aBlock.</body></methods><methods><class-id>SearchToken2</class-id> <category>initialize-release</category><body package="ASKOH">initialize	cSearchMethod := OrderedCollection new.	nOccurrence := 0.</body></methods><methods><class-id>SearchToken2 class</class-id> <category>instance creation</category><body package="ASKOH">with: tokenSymbol	^(super new)		token: tokenSymbol asSymbol;		yourself.</body></methods><methods><class-id>Core.Object class</class-id> <category>class initialization</category><body package="ASKOH">fileInChgSets	"Object fileInChgSets."	| chgsetsDir cFilename |	chgsetsDir := Filename currentDirectory construct: 'chgsets'.	chgsetsDir definitelyExists		ifTrue: 			[cFilename := chgsetsDir directoryContents						collect: [:aString | chgsetsDir construct: aString].			cFilename notEmpty				ifTrue: 					[cFilename := cFilename select: [:aFilename | aFilename extension = '.st'].					cFilename := cFilename								asSortedCollection: [:a :b | a asString &lt;= b asString].					cFilename do: [:aFilename | aFilename fileIn]]]</body></methods><methods><class-id>Core.Object</class-id> <category>ASKOH</category><body package="ASKOH">aDebugTxt	^Filename findDefaultDirectory asString , '\debug.txt'</body><body package="ASKOH">assert: aBlock 	aBlock value ifFalse: [self checkThis]</body><body package="ASKOH">assert: aBlock do: doBlock 	aBlock value ifFalse: [self checkThis].	^doBlock value</body><body package="ASKOH">checkThis	self halt: 'Check this.'</body><body package="ASKOH">debugShow: aString	self toFile: 'debugShow.txt' show: aString</body><body package="ASKOH">deleteDebugTxt	"self deleteDebugTxt. "	| fn |	fn := self aDebugTxt asFilename.	fn definitelyExists ifTrue: [fn delete]</body><body package="ASKOH">equality: aObject 	"Testing an alternative for Object&gt;&gt;="	"Replace 'equality:' with '=' if this method is suitable for a subclass."	^self == aObject or: 			[self class == aObject class and: 					[self basicSize == aObject basicSize and: 							[1 to: self class instSize								do: [:i | ((self instVarAt: i) equality: (aObject instVarAt: i)) ifFalse: [^false]].							1 to: self basicSize								do: [:i | ((self at: i) equality: (aObject at: i)) ifFalse: [^false]].							true]]]</body><body package="ASKOH">isReal	"Answer whether the receiver is a Real number. This 	means essentially that it's an instance of a subclass of 	Number. Since many mathematical operations in the 	system are designed only to work with the Real numbers, 	it's convenient to be able to test for this property."	^false</body><body package="ASKOH">isSymbolic	^false</body><body package="ASKOH">performIfCan: selector else: block 	^self 		performIfCan: selector		withArguments: Array new		else: block</body><body package="ASKOH">performIfCan: selector with: aObject else: block 	^self 		performIfCan: selector		withArguments: (Array with: aObject)		else: block</body><body package="ASKOH">performIfCan: selector with: aObject with: bObject else: block 	^self 		performIfCan: selector		withArguments: (Array with: aObject with: bObject)		else: block</body><body package="ASKOH">performIfCan: selector with: aObject with: bObject with: cObject else: block 	^self 		performIfCan: selector		withArguments: (Array 				with: aObject				with: bObject				with: cObject)		else: block</body><body package="ASKOH">performIfCan: selector withArguments: aArray else: block 	^(self class canUnderstand: selector) 		ifTrue: [self perform: selector withArguments: aArray]		ifFalse: 			[| nSize newArray |			nSize := aArray size + 1.			newArray := Array new: nSize.			newArray at: 1 put: self.			newArray 				replaceFrom: 2				to: nSize				with: aArray.			block valueWithArguments: newArray]</body><body package="ASKOH">postCOPY	"Testing an alternative for Object&gt;&gt;postCopy"	1 to: self class instSize		do: [:i | self instVarAt: i put: (self instVarAt: i) copy].	1 to: self basicSize do: [:i | self basicAt: i put: (self basicAt: i) copy]</body><body package="ASKOH">printForExport	^self printString</body><body package="ASKOH">printOn1: aStream 	| printLimit |	printLimit := 5000.	aStream position &lt; printLimit 		ifTrue: 			[aStream nextPut: $a.			aStream nextPutAll: self class printString.			aStream nextPut: $(.			1 to: self class instSize				do: 					[:i | 					aStream						print: (self instVarAt: i);						space].			1 to: self basicSize				do: 					[:i | 					aStream						print: (self at: i);						space].			aStream nextPut: $).			aStream position &gt; printLimit 				ifTrue: [aStream nextPutAll: (#'...etc...' &lt;&lt; #'CADSM.UI') expandMacros]]</body><body package="ASKOH">printVerbose	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printVerboseOn: aStream.	^aStream contents</body><body package="ASKOH">printVerboseOn: aStream 	self printOn: aStream</body><body package="ASKOH">raiseTranscript	| window model |	ScheduledControllers scheduledControllers do: 			[:controller |			window := controller view.			('VisualWorks*' match: window label asString) ifTrue: [^window raise].			model := controller model.			(model isMemberOf: VisualLauncher) ifTrue: [^window raise]].</body><body package="ASKOH">showContextDepth: i 	| offset |	offset := 1.	self showContextFrom: offset to: offset + i - 1</body><body package="ASKOH">showContextFrom: i to: j 	| stackStream |	stackStream := WriteStream on: (String new: 400).	stackStream		cr;		cr;		nextPutAll: Timestamp now printString;		nextPutAll: (self stackStringFrom: i to: j).	Transcript show: stackStream contents</body><body package="ASKOH">showLabel: aString timeToRun: aBlock	"self new showLabel: 'testing' timeToRun: [1 timesRepeat: [ObjectMemory globalGarbageCollect]]"	| ms |	Transcript		cr;		show: aString.	ms := Time millisecondsToRun: aBlock.	Transcript		cr;		show: aString , ' = ';		show: ms.</body><body package="ASKOH">showObject: aObject ContextDepth: i 	| offset |	offset := 2.	self 		showObject: aObject		ContextFrom: offset		to: offset + i - 1</body><body package="ASKOH">showObject: aObject ContextFrom: i to: j 	| stackStream |	stackStream := WriteStream on: (String new: 400).	stackStream		cr;		cr;		nextPutAll: Timestamp now printString;		cr;		nextPutAll: aObject printString;		nextPutAll: (self stackStringFrom: i to: j).	Transcript show: stackStream contents</body><body package="ASKOH">showObject: aObject ProbeContextDepth: i 	| offset |	offset := 5.	self 		showObject: aObject		ContextFrom: offset + 1		to: offset + i</body><body package="ASKOH">showProbeContextDepth: i 	| offset |	offset := 5.	self showContextFrom: offset + 1 to: offset + i</body><body package="ASKOH">stackStringFrom: i to: j 	| stackStream ctx count |	stackStream := WriteStream on: (String new: 400).	ctx := thisContext.	count := 1.	[ctx notNil and: [count &lt;= j]] whileTrue: 			[count &gt;= i 				ifTrue: 					[stackStream						cr;						print: ctx].			ctx := ctx sender.			count := count + 1].	^stackStream contents</body><body package="ASKOH">toDebugTxt: aString expandMacrosWith: aObject	"self toDebugTxt: '&lt;n&gt;testing = &lt;1p&gt;' expandMacrosWith: nil. "	self		toFile: self aDebugTxt		string: aString		expandMacrosWith: aObject</body><body package="ASKOH">toDebugTxtShowContextFrom: i to: j	"self toDebugTxtShowContextFrom: 1 to: 10."	| stackStream |	stackStream := WriteStream on: (String new: 400).	stackStream		cr;		cr;		nextPutAll: Timestamp now printString;		nextPutAll: (self stackStringFrom: i to: j).	self debugShow: stackStream contents</body><body package="ASKOH">toDebugTxtShowObject: aObject	"self toDebugTxtShowObject: 'testing'. "	self toFile: self aDebugTxt showObject: aObject</body><body package="ASKOH">toFile: filepath show: aString	"self toFile: 'debug.txt' string: 'testing'."	| stream |	stream := filepath asFilename readAppendStream.	[stream nextPutAll: aString] ensure: [stream close]</body><body package="ASKOH">toFile: filepath showObject: aObject	"self toFile: 'debug.txt' showObject: 'testing'. "	self toFile: filepath string: '&lt;1p&gt;' expandMacrosWith: aObject</body><body package="ASKOH">toFile: filepath string: aString expandMacrosWith: object	"self toFile: 'debug.txt' string: '&lt;n&gt;testing = &lt;1p&gt;' expandMacrosWith: nil."	| stream |	stream := filepath asFilename readAppendStream.	[stream nextPutAll: (aString expandMacrosWith: object)]		ensure: [stream close]</body><body package="ASKOH">toTranscript: aString expandMacrosWith: aObject	"self toTranscript: '&lt;n&gt;testing = &lt;1p&gt;' expandMacrosWith: nil."	Transcript show: (aString expandMacrosWith: aObject)</body><body package="ASKOH">when: anEventNameSymbol ask: anObject perform: aSelectorSymbol 	"same as when:send:to:"	| arguments |	aSelectorSymbol isSymbol 		ifFalse: [^self errorBadSelector: aSelectorSymbol].	arguments := Array 				new: (MessageSend numberOfArgumentsFor: aSelectorSymbol).	self when: anEventNameSymbol		evaluate: (MessageSend 				receiver: anObject				selector: aSelectorSymbol				arguments: arguments)</body><body package="ASKOH">when: eventName ask: anObject perform: selector with: argument 	self		when: eventName		send: selector		to: anObject		with: argument</body><body package="ASKOH">when: eventName ask: anObject perform: selector with: firstArgument with: secondArgument 	self		when: eventName		send: selector		to: anObject		with: firstArgument		with: secondArgument</body><body package="ASKOH">when: eventName ask: anObject perform: selector withArguments: argumentList 	self 		when: eventName		send: selector		to: anObject		withArguments: argumentList</body></methods><methods><class-id>Tools.IncrementalSearchDialog class</class-id> <category>dialog opening-predefined</category><body package="ASKOH">requestMethodSelector: prompt	"self requestMethodSelector: 'Browse implementors of selector:' "	| dialog |	dialog := (self new)				module: (IncrementalSearchModule forMethodSelectorEntry: prompt);				entry: TextEditorController currentSelection;				requireSelection: true.	^dialog select ifNotNil: [:entry | entry asSymbol]</body><body package="ASKOH">requestReferencedSymbol: prompt	"self requestReferencedSymbol: 'Browse senders of selector:' "	| dialog |	dialog := (self new)				module: (IncrementalSearchModule forReferencedSymbolEntry: prompt);				entry: TextEditorController currentSelection;				requireSelection: true.	^dialog select ifNotNil: [:entry | entry asSymbol]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="ASKOH">firstDo: firstBlk midDo: midBlk lastDo: lastBlk	| n |	n := self size.	n &gt; 2		ifTrue: 			[firstBlk value: (self at: 1).			2 to: n - 1 do: [:i | midBlk value: (self at: i)].			lastBlk value: (self at: n)]		ifFalse: 			[n = 2				ifTrue: 					[firstBlk value: (self at: 1).					lastBlk value: (self at: n)]				ifFalse: [n = 1 ifTrue: [firstBlk value: (self at: 1)]]]</body><body package="ASKOH">firstDo: firstBlk restDo: restBlk	| n |	n := self size.	n &gt; 1		ifTrue: 			[firstBlk value: (self at: 1).			2 to: self size do: [:i | restBlk value: (self at: i)]]		ifFalse: [n = 1 ifTrue: [firstBlk value: (self at: 1)]]</body><body package="ASKOH">restDo: restBlk lastDo: lastBlk	| n |	n := self size.	n &gt; 1		ifTrue: 			[1 to: n - 1 do: [:i | restBlk value: (self at: i)].			lastBlk value: (self at: n)]		ifFalse: [n = 1 ifTrue: [lastBlk value: (self at: n)]]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>ASKOH</category><body package="ASKOH">messageTally	"Answer a Bag of all the message selectors sent by this method."	| scanner selectorBag selector |	selectorBag := Bag new.	self withAllBlockMethodsDo: 			[:meth |			scanner := InstructionStream on: meth.			scanner scanFor: 					[:byte |					selector := scanner peekForSelector.					selector == nil ifFalse: [selectorBag add: selector].					false	"keep scanning"]].	^selectorBag.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="ASKOH">at: key ifPresent: pBlock ifAbsent: aBlock	| found value |	found := true.	value := self at: key ifAbsent: [found := false].	^found ifTrue: [pBlock value: value] ifFalse: [aBlock value].</body></methods><methods><class-id>Core.Behavior</class-id> <category>ASKOH</category><body package="ASKOH">cAllMethod	"	self cAllMethod.	"	| cAllMethod |	cAllMethod := List new.	self selectorsAndMethodsDo: [:selector :aCompiledMethod | cAllMethod add: aCompiledMethod].	^cAllMethod.</body><body package="ASKOH">cMethodMatching: matchString	"	self new cMethodMatching: '*print*'.	"	| cMethod |	cMethod := List new.	self selectorsAndMethodsDo: 			[:selector :aCompiledMethod |			aCompiledMethod getSource ifNil: [self checkThis]				ifNotNil: [:source | (matchString match: source) ifTrue: [cMethod add: aCompiledMethod]]].	^cMethod.</body></methods><methods><class-id>Searchlight.ResultsView</class-id> <category>actions</category><body package="ASKOH">clickedResult: result	self closeSnippetWindow.	result object isSymbol		ifTrue: [^self triggerEvent: #clickedSymbol: with: result object].	result object searchlightBrowse: (result object searchlightNeedsBrowser				ifTrue: [browser := Refactory.Browser.RefactoringBrowser open]				ifFalse: [nil]).	browser navigator beHierarchy.	self triggerEvent: #clickedResult: with: result</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>ASKOH</category><body package="ASKOH">random	| r |	r := Random new.	^ColorValue		red: r next		green: r next		blue: r next.</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>general inquiries</category><body package="ASKOH">minutesToRun	^(self secondsToRun + 30) // 60.</body><body package="ASKOH">secondsToRun	^((Time microsecondsToRun: self) + 500000) // 1000000.</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>As yet unclassified</category><body package="ASKOH">allSuperNameSpaces	"Answer an OrderedCollection of the receiver's super namespace and the receiver's ancestor's	super namespaces, with the immediate super namespace first."	^parent == nil		ifTrue: [OrderedCollection new]		ifFalse: [parent withAllSuperNamespaces]</body><body package="ASKOH">printHierarchy	| aStream index |	index := 0.	aStream := WriteStream on: (String new: 16).	self allSuperNameSpaces reverseDo: 			[:aNameSpace |			| cClass |			aStream crtab: index.			index := index + 1.			aStream nextPutAll: aNameSpace name.			aStream				space;				nextPut: $(.			cClass := aNameSpace classes.			cClass isEmpty				ifFalse: 					[aStream nextPutAll: (cClass at: 1) name.					2 to: cClass size						do: 							[:i |							aStream								space;								nextPutAll: (cClass at: i) name]].			aStream nextPut: $)].	aStream cr.	self printSubNameSpacesOn: aStream level: index.	^aStream contents</body><body package="ASKOH">printSubNameSpacesOn: aStream level: level	"As part of the algorithm for printing a description of the receiver, print the	subnamespace on the file stream, aStream, indenting level times."	| subs |	aStream crtab: level.	aStream nextPutAll: self name.	aStream		space;		nextPut: $(.	self classes do: [:aClass | aStream nextPutAll: aClass name]		separatedBy: [aStream space].	aStream nextPut: $).	subs := self nameSpaces.	"Print subNamespaces in alphabetical order"	(subs asSortedStrings: 			[:p :x :y |			| collation |			(collation := p collate: x name to: y name) &lt; 0 or: 					[collation = 0						and: [x == y or: [(p collate: x printString to: y printString) &lt;= 0]]]])		do: [:sub | sub printSubNameSpacesOn: aStream level: level + 1]</body><body package="ASKOH">withAllSuperNamespaces	"Answer an OrderedCollection of super namespaces including this namespace in breadth first order."	| subs |	subs := self allSuperNameSpaces.	subs addFirst: self.	^subs</body></methods><methods><class-id>Core.Date</class-id> <category>ASKOH</category><body package="ASKOH">isLastDayOfMonth	^self = self lastDateOfMonth.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="ASKOH">arg1: arg1	^self expandMacrosWithArguments: (Array with: arg1)</body><body package="ASKOH">arg1: arg1 arg2: arg2	^self expandMacrosWithArguments: (Array with: arg1 with: arg2)</body><body package="ASKOH">arg1: arg1 arg2: arg2 arg3: arg3	^self expandMacrosWithArguments: (Array with: arg1 with: arg2 with: arg3)</body><body package="ASKOH">arg1: arg1 arg2: arg2 arg3: arg3 arg4: arg4	^self expandMacrosWithArguments: (Array				with: arg1				with: arg2				with: arg3				with: arg4)</body><body package="ASKOH">args: args	^(StringParameterSubstitution default)		originalString: self;		args: args;		expandedText</body></methods><methods><class-id>Tools.SmalltalkWorkbench class</class-id> <category>browsing</category><body package="ASKOH">browseGlobalFrom: aWindowOrNil	"Browse references to a global variable . Try to track down references that go 	through the global's name as well as direct references via its binding, 	e.g. Smalltalk bindingFor: #UnixProcess"	| dialog |	dialog := IncrementalSearchDialog				forSelectionWithSearch: [:entry | self bindingReferencesMatchingPartialName: entry].	dialog		windowLabel: #BrowseReferences &lt;&lt; #labels					&gt;&gt; 'Browse references to Variable';		firstLabel: #FindC &lt;&lt; #labels &gt;&gt; 'Find:';		secondLabel: #ClassesNamespacesAndVariablesC &lt;&lt; #labels					&gt;&gt; 'Classes, Variables, Name Spaces:';		iconSelector: #safeToolListIcon;		displayStringSelector: #toolListDisplayString;		requireSelection: false;		entry: TextEditorController currentSelection;		objectToStringBlock: [:class | class name asString].	dialog select		ifNotNil: 			[:choice |			choice binding				ifNil: [Dialog warn: #nobody &lt;&lt; #dialogs &gt;&gt; 'Nobody']				ifNotNil: 					[:binding |					| mc |					mc := MethodCollector new.					mc browseSelect: (mc referencesTo: binding)]]</body><body package="ASKOH">promptThenBrowseGlobalNameFrom: aWindowOrNil	"SmalltalkWorkbench promptThenBrowseGlobalNameFrom: nil"	| dialog |	dialog := IncrementalSearchDialog				forSelectionWithSearch: [:entry | self bindingReferencesMatchingPartialName: entry].	dialog		windowLabel: #BrowseClassVariableOrNameSpace &lt;&lt; #labels					&gt;&gt; 'Browse Class, Variable, or Name Space';		firstLabel: #FindC &lt;&lt; #labels &gt;&gt; 'Find:';		secondLabel: #ClassesNamespacesAndVariablesC &lt;&lt; #labels					&gt;&gt; 'Classes, Variables, Name Spaces:';		iconSelector: #safeToolListIcon;		displayStringSelector: #toolListDisplayString;		entry: TextEditorController currentSelection;		objectToStringBlock: [:class | class name asString].	dialog select ifNotNil: [:choice | self browseBindingReference: choice]</body></methods><initialize><class-id>SearchMethod2</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>ResultsView</name><environment>Searchlight</environment><super>Searchlight.ControllerView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchResults browser snippetWindow abortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Tools</package></attributes></class><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>